%% \item
% pdfplatex thesis_nakano
%\includegraphics[height=5.0cm, width=5.0cm, bb=0 0 500 500]
% caption{name}
%import processing.pde.*;
%size(500,500,PDF, "outputCJS/ファイル名.pde");   setup()内
% \cite{Tanaka1}
\documentclass[12pt]{optlab-bachelor}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage[dvipdfmx]{graphicx}
% 各自変更するように
\def\年度{２０１８}
\def\氏名{中野　壱帥}
\def\学生番号{15715051}
\def\題目{多目的最短経路問題における
\\動的計画法に基づいた
\\拡張ベルマンフォード法の提案
}

\def\背題目{多目的最短経路問題における
\\動的計画法に基づいた拡張ベルマンフォード法の提案}
% 削除しないように！
\renewcommand{\bibname}{参考文献}

\begin{document}
\frontmatter % 削除しないように！
\chapter{はじめに}
\section{研究背景}
現代には道路ネットワークや通信ネットワークなど様々なネットワークが存在する．
これらのネットワークには無数の経路や組み合わせが存在するため最適化した解を求めたい．
しかし，これらのネットワークに対する最適化を行う場合，複数の目的関数を考慮することが必要である．
例えば，道路ネットワークでは目的地までの時間とコストを最小化する必要がある．
このように複数の目的関数値を最大化（最小化）する解を求める問題は多目的最適化問題と呼ばれている．
多目的最適化問題の中でも，最短経路を求める問題は多目的最短経路問題と呼ばれている．

多目的最適化問題においては，それぞれの目的関数がトレードオフの関係にある場合が存在し，
全ての目的関数値が最大（最小）となる最適解が存在するとは限らない．
あらかじめ各目的関数に対する比重を決めて解を求めると1つの解が適切に求めることができる．
しかし，探索者の各目的関数に対する比重が決まっていない場合や複数の探索者がいる場合，
求まった1つの解がそれぞれの探索者に対して適切な解ではない場合がある．
そこで，最適解になり得るパレート最適解の集合を求める．
探索者が1つの解を求めるとき，パレート最適解の集合を求めることにより解を選択する意思決定を容易にできる．
また，それぞれの探索者が最適解となり得る解の集合から解を選択できるので，
それぞれの探索者が最適な解を求めることができる．
一般にパレート最適解は膨大な数存在するので効率的に列挙することが必要になる.

単一目的最短経路問題には負の要素を考慮した解法が提案されているが，
調査した限り従来の多目的最短経路問題には負の要素を考慮した研究がなされていない．
単一目的最短経路問題において負の要素を考慮した場合，負のサイクルが存在し解が求められない場合がある．
しかし，多目的最短経路問題において負の要素を考慮した場合，１つの目的関数において負のサイクルが存在しても
他の目的関数に対する解を求められる場合がある．
そこで，負の要素を含む多目的最短経路問題において負のサイクルが存在しない目的関数に対する
効率的な解法を考える．

\section{研究目的}
本研究では，多目的最短経路問題において一般的に膨大な数存在するとされるパレート解を効率的に列挙する．
従来研究で提案されている拡張ダイクストラ法等にはインスタンスによって
探索順序が適切でなかったり実装するにあたって改善点が多くある．
また，従来研究では負の要素を考慮していないため負のサイクル存在時の解の定義がされていない．
本研究では，オフライン環境における多目的最短経路問題に対して以下を目的とする．

\begin{description}
  \item[目的１:]
  多目的最短経路問題に対する効率的解法を行う．
\end{description}

多目的最適化問題におけるパレート解列挙の複雑さを踏まえて，解法の提案を行う．
また，計算機を用いて解法の実験的評価を行う．

\begin{description}
  \item[目的２:]
  負の要素を考慮した解法を行う．
\end{description}

負のサイクルが存在する場合の解を定義し効率的な解法の提案を行う．
また，計算機を用いて解法の実験的評価を行う．

\section{章構成}

  本論文の章構成は以下である．
  \begin{itemize}
  \item 第２章では，多目的最適化問題と最短経路問題に対する定義を紹介し，多目的最短経路問題の解に対する定義を行う．
  \item 第３章では，多目的最短経路問題に対する従来研究を紹介する．
  \item 第４章では，提案解法の紹介と実装における工夫，本研究に対する成果を述べる．
  \item 第５章では，結論として本研究の成果と今後の課題について述べる．
\end{itemize}

\chapter{諸定義}
この章では，多目的最適化問題と最短経路問題に対する定義を紹介する．
多目的最適化問題における解となるパレート解の説明をする．単一目的最短経路問題に対する解法を紹介する．
また，多目的最短経路問題の解に対する定義を行う．本研究における定式化をする．（負の要素を考慮した場合を含む）

\section{多目的最適化問題}
最適化問題とは与えられたインスタンスに対して実行可能な最適解を求める問題である．
最適化問題のインスタンスは特定の集合上で定義された実数値関数または整数値関数
$f : A \rightarrow \mathbb{R}$で定義される．
最小化問題の場合，$minf(x)$となる$x$を求める．
すなわち，$x_0 \in A : \forall x\in A , f(x_0) \leq f(x) $となる$x_0$を求める．
最大化問題の場合，$maxf(x)$となる$x$を求める．

多目的最適化問題とは複数の目的関数に対する最適化問題である．
多目的最適化問題のインスタンスは最適化目的の数が$n$である場合，
$n$個の実数値関数または整数値関数$f : A \rightarrow \mathbb{R}$で定義される．
すなわち，$\vec{f} = (f_1 , \ldots , f_n)$と表される．
最小化問題の場合，$min\vec{f(x)}$となる$x$を求める．
多目的最適化問題の場合，それぞれの目的関数がトレードオフの関係にある場合が存在し，
全ての目的関数値が最大（最小）となる最適解が存在するとは限らない．
（例：$f_1(x_0) < f_2(x_0) \land f_1(x_1) > f_2(x_1)$)
一般的に，多目的最適化問題はパレート最適解の集合を求める．
パレート最適解は複数の目的関数をそのまま考慮された解なので，
求めたい選好解を見つけることや挙動変数の関係を知ることが可能になる．

\section{パレート最適解}
パレート最適解は，多目的最短経路問題のにおける解の支配関係により定義される．
解 $x,y$ が以下の条件を満たすとき，$x$ は $y$ を支配する．
\begin{itemize}
\item $\forall i \in \{1,\ldots,k\},f_i(x) \le f_i(y)$
\item $\exists i \in \{1,\ldots,k\},f_i(x) < f_i(y)$
\item $k$：最適化目的の数，$f$：目的関数
\end{itemize}
パレート最適解とは取りうる値の範囲を全て考慮した上で支配されない解である．

図1に，目的関数の数が2の場合のパレート最適解の例を示す．
図中の黒丸がパレート最適解を示している．

\section{最短経路問題}
有向もしくは無向グラフをグラフ$G=(V,E)$と表す．
グラフは頂点集合$V=\{v_1,\ldots,v_n\}$，辺集合$E=\{e_1,\ldots,e_m\}$から成る．
重み付きグラフの場合，全ての辺$e\in E$は重み$e_w$を持つ．
無向グラフにおいて，両端点を$s,t$とする辺$e \in E$を$s,t \in e$と表す．
有向グラフにおいて，始点を$s$，終点を$t$とする辺$e \in E$を$e=(s,t)$と表す．
$s$から$t$までの距離を$d_{s,t}$と表す．
最短経路問題とは重み付きグラフ$G=(V,E)$の与えられた2つのノード$s,t$間を結ぶ経路の中で，
重みが最小の経路($min$ $d_{s,t}$となる経路)を求める最適化問題である．

\begin{description}
  \item[最短経路問題の種類]
\end{description}
\begin{itemize}
\item ２頂点対最短経路問題：特定の２つのノード間の最短経路問題．
\begin{itemize}
  \item[入力：]重み付きグラフ，始点$s$，終点$t$
  \item[出力：]$s$から$t$への最短経路
\end{itemize}
\item 単一始点最短経路問題：特定の１つのノードから他の全ノードとの間の最短経路問題．
\begin{itemize}
  \item[入力：]重み付きグラフ，始点$s$
  \item[出力：]$s$から全頂点への最短経路
\end{itemize}
\item 全点対最短経路問題：グラフ内のあらゆる２ノードの組み合わせについての最短経路問題．
\begin{itemize}
  \item[入力：]重み付きグラフ
  \item[出力：]全頂点間の最短経路
\end{itemize}
\end{itemize}
\begin{description}
  \item[最短経路問題の主な解法]
\end{description}

\begin{itemize}
  \item 幅優先探索

  始点から近い順に探索する．
  重みがない（すべての重みが１である）最短経路問題に使われる．
  通った辺の本数に応じて重みが決まるため探索によって発見した頂点は最短経路が決定する．
  計算時間は $O(E)$である．
  以下に無向グラフにおける単一始点最短経路問題の解法を示す．

  \begin{quote}
    \begin{description}
      \item[入力：] グラフ$G=(V,E)$，始点$s \in V$，$Q \leftarrow \emptyset$
      \item[出力：] $s$から全ての頂点への経路
      \item[Step 1.] $Q \leftarrow s$
      \item[Step 2.] $Q = \{\emptyset\}$になるまで以下の操作を行う．
      \begin{description}
        \item[Step 2-1.] $Q$の先頭にあるノード$v$を取り出す．
        \item[Step 2-2.] $u = \{u \in V \mid v,u \in e \land e \in E\}$が未探索のとき，
        $Q \leftarrow u$．
      \end{description}

      \item[Step 3.] 経路を出力する．
    \end{description}
  \end{quote}
  ２頂点対最短経路問題の場合，終点が見つかった時点で探索を終了し，
  始点から終点への経路を出力する．
  入力が有向グラフの場合：
  \begin{quote}
    \begin{description}
      \item[Step 2-2.] $u = \{u \in V \mid e = (v,u) \land e \in E\}$が未探索のとき，
      $Q \leftarrow u$．
    \end{description}
  \end{quote}
\end{itemize}

\begin{itemize}
  \item ダイクストラ法

  全ての重みが非負数であるグラフについての有名なアルゴリズムである
  ダイクストラ法について説明をする．
  ダイクストラ法はDijkstera E W\cite{Dijkstera}によって開発された．
  ダイクストラ法は全ての重みが非負数であるグラフにおいて使われる．
  探索手順はすでに探索済みのノードの中で重みが最小のノードを
  求め，更新対象として探索していく．
  全ての重みが非負数の場合，探索したノードの中で重みが最小のものは
  その後の探索で更新されることはないので重みが決定する．
  ダイクストラ法の計算時間は $O(V^2)$である．
  以下に無向グラフにおける単一始点最短経路問題の解法を示す．

  \begin{quote}
    \begin{description}
      \item[入力：] グラフ$G=(V,E)$，始点$s \in V$，$E$の各辺の長さ，$Q \leftarrow \emptyset$
      \item[出力：] $s$から全ての頂点への経路
      \item[Step 1.] $s_w = 0$とし，$v \in V/ \{ s\}$に対して$v_w = \infty$とする．
      \item[Step 2.] $Q \leftarrow s$
      \item[Step 3.] $Q = \{\emptyset\}$になるまで以下の操作を行う．
      \begin{description}
        \item[Step 3-1.] $v = \{ v \in Q \mid v_w \leq v'_w \land v' \in Q \}$
        を取り出す．
        \item[Step 3-2.] $e = \{ e \in E \mid v \in e \}$について以下の操作を行う．

        \begin{description}
          \item[Step 3-2-1.] $u = \{ u \in V \mid u \in e\}$となる$u$に対して，
          $u_w > v_w + e_w$を満たすとき以下の操作を行う．

          \begin{description}
            \item[Step 3-2-1-1.] $u_w = v_w + e_w$.
            \item[Step 3-2-1-2.] $u \notin Q$のとき，$Q \leftarrow u$．
          \end{description}
        \end{description}
      \end{description}

      \item[Step 4.] 経路を出力する．
    \end{description}
  \end{quote}
\end{itemize}
２頂点対最短経路問題の場合，終点が更新対象となった時点で探索を終了し，
始点から終点への経路を出力する．
入力が有向グラフの場合:
\begin{quote}
\begin{description}
\item[Step 3-2.] $u = \{ u \in V \mid (v,u) = e \land e \in E \}$となる$u$に対して，
$u_w > v_w + e_w$を満たすとき以下の操作を行う．
\begin{description}
  \item[Step 3-2-1.] $u_w = v_w + e_w$.
  \item[Step 3-2-2.] $u \notin Q$のとき，$Q \leftarrow u$．
\end{description}
\end{description}
\end{quote}

\begin{itemize}
  \item ベルマンフォード法

  グラフ内の全ての重みが非負数であるかどうかに関わらず使用できる有名なアルゴリズムである
  ベルマンフォード法について説明をする．
  ベルマンフォード法はBellman Rら \cite{Bellman}によって開発された．
  全ての重みが実数であるグラフにおいて使われる．（負の値を含んでいても使用できる）
  ベルマンフォード法の探索順序は
  頂点数を $|V|$ とした時，全辺を緩めることを単に $|V|-1$ 回繰り返す．
  辺$e$を緩めるとは，$e$に接続しているノードの重みを$v_w,u_w$とし，
  $e$の重みを$e_w$としたとき，$u_v$が$v_w+e_w$によって更新されることである．
  $|V|-1$ 回の探索終了時にもう一度全辺を緩め，
  更新が行われた場合は負の閉路が存在するため負の閉路の存在を報告する．
  負の閉路が存在しない場合はpathの長さの最大が全頂点を通る$|V|-1$となる．
  負の閉路が存在する場合は無限に更新が行われるため，$|V|$回目の探索でも更新が行われる．
  よって，$|V|$回目の探索により負の閉路の存在有無を確かめられる．
  ベルマンフォード法の計算時間は $O(EV)$である．
  以下に無向グラフにおける単一始点最短経路問題の解法を示す．

  \begin{quote}
    \begin{description}
      \item[入力：] グラフ$G=(V,E)$，始点$s \in V$，$E$の各辺の長さ
      \item[出力：] $s$から全ての頂点への経路，負の閉路の存在有無
      \item[Step 1.] $s_w = 0$とし，$v \in V/\{s\}$に対して$v_w = \infty$とする．
      \item[Step 2.] $|V|-1$ 回以下の操作を行う．
      \begin{description}
        \item[Step 2-1.] $e = {e \in E \mid v,u \in e}$となる$e$に対して，
        $u_w > v_w + e_w$を満たすとき以下の操作を行う．
        \begin{description}
          \item[Step 2-1-1.] $u_w = v_w + e_w$.
        \end{description}
      \end{description}
      \item[Step 3.] Step 2-1を行いノードの重みが更新された場合，
      負の閉路の存在を報告する．
      \item[Step 4.] 経路を出力する．
    \end{description}
  \end{quote}
  ２頂点対最短経路問題の場合，単一始点最短経路問題を解き，
  始点から終点への経路を出力する．
  入力が有向グラフの場合:
  \begin{quote}
    \begin{description}
      \item[Step 2-1.] $e = {e \in E \mid (v,u) = e}$となる$e$に対して，
      $u_w > v_w + e_w$を満たすとき以下の操作を行う．
      \begin{description}
        \item[Step 2-1-1.] $u_w = v_w + e_w$.
      \end{description}
    \end{description}
  \end{quote}
\end{itemize}

\begin{itemize}
  \item ワーシャルフロイド法

  グラフ内の全ての重みが非負数であるかどうかに関わらないかつ
  全点対最短経路をもとめる際に使用できる有名なアルゴリズムである
  ワーシャルフロイド法について説明をする．
  ワーシャルフロイド法はR. W. Floydら \cite{Floyd}によって開発された．
  ワーシャルフロイド法は重み付き有向グラフにおいて全点対最短経路を多項式時間で解くアルゴリズムである．
  3つの頂点a, b, cを選んで、a→b→cという道がa→cという道より短ければa→cの距離を更新する
  という操作を全ての頂点の組み合わせで繰り返して最短距離を確定させていく．
  a, b, cはそれぞれ$|V|$の選択が出来るので，
  a→b→cという道がa→cという道より短ければa→cの距離を更新する
  という操作は$|V|^3$回行われる．
  $|V|^3$回の操作後，更新できる解が存在する場合は負の閉路が存在する．
  ワーシャルフロイド方は負の値にも対応でき，計算時間は $O(V^3)$である．
  以下に全点対最短経路問題の解法を示す．

  \begin{quote}
    \begin{description}
      \item[入力：] グラフ$G=(V,E)$，始点$s \in V$，$E$の各辺の長さ
      \item[出力：] 全頂点対の経路
      \item[Step 1.] $s_w = 0$とし，$v \in V/\{s\}$に対して$v_w = \infty$とする．
      \item[Step 2.] 各$1<k<|V|$に対して以下の操作を行う．
      \begin{description}
        \item[Step 2-1.] 各$1<i<|V|$に対して以下の操作を行う．
        \begin{description}
          \item[Step 2-1-1.] 各$1<j<|V|$に対して以下の操作を行う．
          \begin{description}
            \item[Step 2-1-1-1.] $d_{i,j} > d_{i,k} + d{k,j}$を満たすとき，
            $d_{i,j} = d_{i,k} + d{k,j}$
          \end{description}
        \end{description}
      \end{description}

      \item[Step 3.] 経路を出力する．
    \end{description}
  \end{quote}
  2頂点間の距離がマイナスの場合，負の閉路が存在する．
\end{itemize}

\section{多目的最短経路問題}
多目的最短経路問題とは，最短経路問題の最適化目的の数を複数にすることによって，
多目的最適化問題に拡張した問題である．
つまり，目的値が複数の重み付きグラフにおいて与えられた２つのノード間を結ぶ経路の中で，
パレート最適解となる経路を求める最適化問題である．
有向もしくは無向グラフをグラフ$G=(V,E)$と表す．
グラフは頂点集合$V=\{v_1,\ldots,v_n\}$，辺集合$E=\{e_1,\ldots,e_m\}$から成る．
最適化目的の数を$k$とするとき，全ての辺$e\in E$は重み$\vec{e_w} = \{e_{w1},\ldots,e_{wk}\}$を持つ．
無向グラフにおいて，両端点を$s,t$とする辺$e \in E$を$s,t \in e$と表す．
有向グラフにおいて，始点を$s$，終点を$t$とする辺$e \in E$を$e=(s,t)$と表す．
$s$から$t$までの距離を$\vec{d_{s,t}} = \{d_{s,t1},\ldots,d_{s,tk}\}$と表す．
また，本研究では全ての値が同じとなる経路は１つのみ求める．
\begin{description}
  \item[多目的最短経路問題の種類]
\end{description}
\begin{itemize}
\item 多目的２頂点対最短経路問題：特定の２つのノード間の最短経路問題．
  \begin{itemize}
    \item[入力：]重み付きグラフ，始点$s$，終点$t$，最適化目的の数$k$
    \item[出力：]$s$から$t$へのパレート最適解となる経路の集合
  \end{itemize}
  \item 多目的単一始点最短経路問題：特定の１つのノードから他の全ノードとの間の最短経路問題．
  \begin{itemize}
    \item[入力：]重み付きグラフ，始点$s$，最適化目的の数$k$
    \item[出力：]$s$から全頂点へのパレート最適解となる経路の集合
  \end{itemize}
  \item 多目的全点対最短経路問題：グラフ内のあらゆる２ノードの組み合わせについての最短経路問題．
  \begin{itemize}
    \item[入力：]重み付きグラフ，最適化目的の数$k$
    \item[出力：]全頂点間のパレート最適解となる経路の集合
  \end{itemize}
\end{itemize}
\begin{description}
  \item[負の値を含む場合]
\end{description}

単目的最短経路問題では負の閉路が存在する場合，負の閉路の存在を報告し
最短経路は求めなかった．これは負の閉路を何度も通過することによって
重みを更新し続けるためである．
しかし，多目的最短経路問題の場合，目的関数が複数存在するので
１つの目的関数において負の閉路が存在する場合でも，
他の目的関数による最適化をすることで解を求めることができる．
よって，本研究では負の閉路が存在する目的関数を考慮しない解を求める．


\section{関連研究}



\chapter{従来研究}
この章では多目的最短経路問題に対する従来研究の成果を紹介する．

\section{拡張ダイクストラ法}
従来研究としてN.Takahashiら\cite{N.TAKAHASHI1}に提案された
拡張ダイクストラ法について説明をする．
拡張ダイクストラ法の探索順序は探索済みの頂点$v$を指定し，
$v$に隣接する頂点$u$に対する解を更新していく方法である．

また，いくつかの工夫によって探索空間を削除することが可能である．
拡張ダイクストラ法は全ての値が非負数の場合のみ使用できる．
以下に無向グラフに対するアルゴリズムを記載する．

\begin{quote}
  \textbf{記号}
  \begin{description}
    \item[$k$：] 最適化目的の数
    \item[$v \in V$に対して]
    \item[$W_v$：] ノード$v$に隣接するノード集合
    \item[$v \in V$，$j = 1 , \ldots , k$に対して]
    \item[$l_{jv}$：] 始点からノード$v$に到達したときに生じる
    第$j$番目の目的関数における総コスト
    \item[$e \in E$，$j = 1 , \ldots , k$に対して]
    \item[$e_{jw}$：] 辺$e$の第$j$番目の目的関数におけるコスト
  \end{description}
\end{quote}

\begin{quote}
  \textbf{アルゴリズム}
  \begin{description}
    \item[入力：] グラフ$G=(V,E)$，始点$s \in V$，最適化目的の数$k$，
    各辺の重みを返す関数$w : E \to \mathbb{R}^k$
    \item[出力：] $s$から全ての頂点への最短経路となるパレート解の集合
    \item[Step 1.] $L_v \leftarrow (s,0,\ldots,0)$，
    $W_v \leftarrow \emptyset$，$v \leftarrow s$
    \item[Step 2.] $W_v$を求める．
    \item[Step 3.] $W_v$内のノード全てに対して以下の操作を行う．
    \begin{description}
      \item[Step 3-1.] $\omega \in W_v$を選択する．
      \item[Step 3-2.] $(v,l_{1v},\ldots,l_{kv}) \in L_v$を選択する．
      \item[Step 3-3.] 始点が$v$，終点が$\omega$である辺$e$の重みベクトルを
      $\vec{e} = (e_{1w},\ldots,e_{kw})$とし，
      $(\omega,l^*_{1\omega},\ldots,l^*_{k\omega}) \leftarrow
      (\omega,l_{1v}+e_{1w},\ldots,l_{kv}+e_{kw})$とする．
      \item[Step 3-4.] $L_v$と
      $(\omega,l^*_{1\omega},\ldots,l^*_{k\omega})$に対して
      パレート最適解の判定を行う．
      \item[Step 3-5.] 全ての頂点$v \in V$が探索されていないとき，
      $v' \in W_v$を選択し，$v \leftarrow v'$としてStep 2に戻る．
    \end{description}
    \item[Step 4.] 全てのパレート解を出力
  \end{description}
\end{quote}

\begin{quote}
  \textbf{パレート最適解の判定}
  \begin{description}
    \item[Step 1.] $L_v$と$(\omega,l^*_{1\omega},\ldots,l^*_{k\omega})$
    を受け取る．
    \item[Step 2.] $L_v$の全てのラベルに対して以下の操作を行う．
    \begin{description}
    \item[Step 2-1.] $(\omega,l'_{1\omega},\ldots,l'_{k\omega}) \in L_v$
    を選択する．
    \item[Step 2-2.] 以下の条件を満たすとき，$L_v$を返す．
    \begin{itemize}
      \item $\forall i \in \{1,\ldots,k\},l'_{i\omega} \le l^*_{i\omega}$
    \end{itemize}
    \item[Step 2-3.] 以下の条件を満たすとき，
    $L_v \leftarrow L_v \setminus \{(\omega,l'_{1\omega},\ldots,l'_{k\omega})\}$．
    \begin{itemize}
      \item $\forall i \in \{1,\ldots,k\},l^*_{i\omega} \le l'_{i\omega}$
      \item $\exists i \in \{1,\ldots,k\},l^*_{i\omega} < l'_{i\omega}$
    \end{itemize}
    \end{description}
    \item[Step 3.]
    $L_v \leftarrow L_v \cup \{(\omega,l^*_{1\omega},\ldots,l^*_{k\omega})\}$を返す．
  \end{description}
\end{quote}

\section{完全多項式時間近似スキームによる解法}
従来研究としてThomas Breugemら\cite{Breugem}に提案された
完全多項式時間近似スキームによる解法について説明をする．
完全多項式時間近似スキームとは，
入力サイズが$n$，精度が$1 / \epsilon(\epsilon > 0)$
となる多項式時間アルゴリズムである．
また，任意の整数$\epsilon > 0$に対して$\alpha = 1+\epsilon$
とできる入力サイズの多項式時間アルゴリズムを多項式時間近似スキームという．
従来は全ての解に対して更新を行なっていたが更新しなくても良い解があるため無駄が生じてしまっている．
また，単目的最短経路問題と違い更新する際の比較対象が多く存在することから１回の更新でも
より多くの時間や作業が必要となるため無駄な更新を避けることによって大きな効率化に繋がると予想できる．
完全多項式時間近似スキームによる解法は更新対象とする解のラベルと更新対象としない解のラベルを用意する
ことによって無駄な更新を削減し効率化することを目的としたアルゴリズムである．
しかし，２つのラベルを用意するため多少メモリを多く使う．
また，頂点毎の更新ではなく発見された解から順に更新されていくため，更新順序も異なる．
更新順序が異なると従来では一度解になり後の更新で削除されるはずだった解が解とならずに探索が進んでいく場合や，
従来では解にならなかったものが一度解として記憶される場合があるため探索中に更新する解の数や
削除される解の数が異なる．探索中に更新する解の数や削除される解の数が異なる
ことによって実装時間が異なる場合もある．
今回のアルゴリズムはラベルを2つ用意し，それぞれ以下とする．
\begin{itemize}
\item パレート解となり得るかつ更新対象としない解のラベル
\item パレート解となり得るかつ更新対象とする解のラベル
\end{itemize}
更新対象とするラベルと更新対象としないラベルを分けることによってすでに更新した
解を再度更新する無駄がなくなるため実装時間は短くなる．
以下に無向グラフに対するアルゴリズムを記載する．

\begin{quote}
  \textbf{記号}
  \begin{description}
    \item[$k$：] 最適化目的の数
    \item[$v \in V$，$j = 1 , \ldots , k$に対して]
    \item[$l_{jv}$：] 始点からノード$v$に到達したときに生じる
    第$j$番目の目的関数における総コスト
    \item[$e \in E$，$j = 1 , \ldots , k$に対して]
    \item[$e_{jw}$：] 辺$e$の第$j$番目の目的関数におけるコスト
    \item[$L_T$：] 更新対象とするラベル
    \item[$L_P$：] 更新対象としないラベル
  \end{description}
\end{quote}

\begin{quote}
  \textbf{アルゴリズム}
  \begin{description}
    \item[入力：] グラフ$G=(V,E)$，始点$s \in V$，最適化目的の数$k$，
    各辺の重みを返す関数$w : E \to \mathbb{R}^k$
    \item[出力：] $s$から全ての頂点への最短経路となるパレート解の集合
    \item[Step 1.] $L_T \leftarrow (s,0,\ldots,0)$，
    $L_P \leftarrow \emptyset$
    \item[Step 2.] $L_T = \{\emptyset\}$となるまで以下の操作を行う．
    \begin{description}
      \item[Step 2-1.] $L_T$の先頭にある
      $(\omega,l_{1\omega},\ldots,l_{k\omega})\in L_T$を選択する．
      \item[Step 2-2.] $L_T \leftarrow L_T \setminus
      \{ (\omega,l_{1\omega},\ldots,l_{k\omega}) \}$
      \item[Step 2-3.] 以下の条件を満たすとき,
      $L_P \leftarrow L_P \cup \{(\omega,l_{1\omega},\ldots,l_{k\omega})\}$とする．
      \begin{itemize}
        \item 任意の$(\omega^*,l_{1\omega^*},\ldots,l_{k\omega^*})\in L_P$に
        $(\omega,l_{1\omega},\ldots,l_{k\omega})$が支配されない．
        \item 任意の$(\omega^*,l_{1\omega^*},\ldots,l_{k\omega^*}) \in L_P$と
        $(\omega,l_{1\omega},\ldots,l_{k\omega})$における全ての目的関数値が同値でない．
      \end{itemize}
      \item[Step 2-4.] 頂点$\omega$に辺$e$によって接続している頂点$u$
      に対して以下の操作を行う．
      \begin{description}
        \item[Step 2-4-1.] 辺$e$の重みベクトルを
        $\vec{e} = (e_{1w},\ldots,e_{kw})$とし，
        $(\omega',l_{1\omega'},\ldots,l_{k\omega'}) \leftarrow
        (\omega',l_{1\omega}+e_{1w},\ldots,l_{k\omega}+e_{kw})$とする．
        \item[Step 2-4-2.] 以下の条件を満たすとき，
        $L_T \leftarrow L_T \cup \{(\omega',l_{1\omega'},\ldots,l_{k\omega'})\}$とする．
        \begin{itemize}
          \item 任意の$(\omega^*,l_{1\omega^*},\ldots,l_{k\omega^*})\in L_P \cup L_T$に
          $(\omega',l_{1\omega'},\ldots,l_{k\omega'})$が支配されない．
          \item 任意の$(\omega^*,l_{1\omega^*},\ldots,l_{k\omega^*}) \in L_P \cup L_T$と
          $(\omega',l_{1\omega'},\ldots,l_{k\omega'})$における全ての目的関数値が同値でない．
        \end{itemize}
        \item[Step 2-4-3.] 任意の$(\omega'',l_{1\omega''},\ldots,l_{k\omega''})\in L_T$
        に対して$(\omega',l_{1\omega'},\ldots,l_{k\omega'})$が
        $(\omega'',l_{1\omega''},\ldots,l_{k\omega''})$を支配しているとき，
        $L_T \leftarrow L_T \setminus \{(\omega'',l_{1\omega''},\ldots,l_{k\omega''})\}$とする．
      \end{description}
    \end{description}
    \item[Step 3.] 全てのパレート解を出力
  \end{description}
\end{quote}

\begin{quote}
  \textbf{支配}

    解 $x,y$ が以下の条件を満たすとき，$x$ は $y$ を支配する．
    \begin{itemize}
      \item $\forall i \in \{1,\ldots,k\},f_i(x) \le f_i(y)$
      \item $\exists i \in \{1,\ldots,k\},f_i(x) < f_i(y)$
      \item $k$：最適化目的の数，$f$：目的関数
    \end{itemize}
\end{quote}

\section{ラベル付けアルゴリズムによる解法}
従来研究としてJosé Luis E. Dos Santosら\cite{Santos}に提案された
ラベル付けアルゴリズムによる解法について説明をする．
ラベル付けアルゴリズムとはいくつかのラベルを用意し，
解を分けて記憶することにより条件毎の解を参照しやすくするアルゴリズムである．
ラベル付けアルゴリズムによる解法では頂点数だけラベルを用意し，
各頂点毎の解をそれぞれのラベルに記憶していく．
従来のアルゴリズムでは１つのラベルから更新対象となる頂点に対する解を探索し
解の更新を行なっていたが，１つのラベルには全ての頂点に対する解が存在するため
多くの解に対して更新対象とするかの判定を行わなけらばならない．
ラベル付けアルゴリズムによる解法により各頂点毎の解を分けて保存しておくことが可能なので
更新対象となる頂点に対する解を選択するときに探索を行う必要がなくなり効率化になると考えられる．
ラベル付けアルゴリズムによる解法の探索方法はベルマンフォード法を改良したもので，
未更新の頂点集合を用意し，未更新の頂点がなくなるまで全辺を緩めて更新する．
ベルマンフォード法のように全ての解に対して更新を行なってしまうと無駄な更新が多く行われてしまうため
未更新の頂点集合（前回の探索によって発見された解に対する頂点集合）を
用意することによって無駄な更新を削減している．
以下に無向グラフに対するアルゴリズムを記載する．

\begin{quote}
  \textbf{記号}
  \begin{description}
    \item[$k$：] 最適化目的の数
    \item[$v \in V$に対して]
    \item[$L_v$：] 頂点$v$に対するラベル
    \item[$v \in V$，$j = 1 , \ldots , k$に対して]
    \item[$l_{jv}$：] 始点からノード$v$に到達したときに生じる
    第$j$番目の目的関数における総コスト
    \item[$e \in E$，$j = 1 , \ldots , k$に対して]
    \item[$e_{jw}$：] 辺$e$の第$j$番目の目的関数におけるコスト
    \item[$X$：] 更新対象とする頂点集合
  \end{description}
\end{quote}

\begin{quote}
  \textbf{アルゴリズム}
  \begin{description}
    \item[入力：] グラフ$G=(V,E)$，始点$s \in V$，最適化目的の数$k$，
    各辺の重みを返す関数$w : E \to \mathbb{R}^k$
    \item[出力：] $s$から全ての頂点への最短経路となるパレート解の集合
    \item[Step 1.] $\forall v \in V , L_v \leftarrow \emptyset$，
    $L_s \leftarrow (s,0,\ldots,0)$，$X \leftarrow s$
    \item[Step 2.] $X = \{\emptyset\}$となるまで以下の操作を行う．
    \begin{description}
      \item[Step 2-1.] $v \in X$となる頂点$v$を選択する．
      \item[Step 2-2.] $X \leftarrow X \setminus \{ v \}$
      \item[Step 2-3.] $e = {e \in E \mid v,u \in e}$となる
      $e$に対して以下の操作を行う．
      \begin{description}
        \item[Step 2-3-1.] 頂点$v$に対する全てのpath
        $(v',l_{1v'},\ldots,l_{kv'}) \in L_v$に対して以下の操作を行う．
        \begin{description}
          \item[Step 2-3-1-1.] 辺$e$の重みベクトルを
          $\vec{e} = (e_{1w},\ldots,e_{kw})$とし，
          $(u',l_{1u'},\ldots,l_{ku'}) \leftarrow
          (u',l_{1v}+e_{1w},\ldots,l_{kv}+e_{kw})$とする．
          \item[Step 2-3-1-2.] 以下の条件を満たすとき，
          $L_u \leftarrow L_u \cup \{(u',l_{1u'},\ldots,l_{ku'})\}$，
          $X \leftarrow X \cup \{ u\}$とする．
          \begin{itemize}
            \item 任意の$(u^*,l_{1u^*},\ldots,l_{ku^*})\in L_u$に
            $(u',l_{1u'},\ldots,l_{ku'})$が支配されない．
            \item 任意の$(u^*,l_{1u^*},\ldots,l_{ku^*}) \in L_u$と
            $(u',l_{1u'},\ldots,l_{ku'})$における全ての目的関数値が同値でない．
          \end{itemize}
          \item[Step 2-3-1-3.] 任意の$(u'',l_{1u''},\ldots,l_{ku''})\in L_u$
          に対して$(u',l_{1u'},\ldots,l_{ku'})$が
          $(u'',l_{1u''},\ldots,l_{ku''})$を支配しているとき，
          $L_u \leftarrow L_u \setminus \{(u'',l_{1u''},\ldots,l_{ku''})\}$とする．
        \end{description}
      \end{description}
    \end{description}
    \item[Step 3.] 全てのパレート解を出力
  \end{description}
\end{quote}

\begin{quote}
  \textbf{支配}

    解 $x,y$ が以下の条件を満たすとき，$x$ は $y$ を支配する．
    \begin{itemize}
      \item $\forall i \in \{1,\ldots,k\},f_i(x) \le f_i(y)$
      \item $\exists i \in \{1,\ldots,k\},f_i(x) < f_i(y)$
      \item $k$：最適化目的の数，$f$：目的関数
    \end{itemize}
\end{quote}


\chapter{解法の提案と実験的評価}
この章では，多目的最短経路問題についての分析を行い解法の考察をする．
その後，提案解法の紹介と実装における工夫，本研究に対する成果を述べる．

\section{問題の分析}
本研究では多目的単一始点最短経路問題を扱う．
多目的単一始点最短経路問題とは特定の１つのノードから他の全ノードとの間の最短経路問題であり，
入力と出力は以下のようになる．
\begin{itemize}
  \item[入力：]重み付きグラフ，始点$s$，最適化目的の数$k$
  \item[出力：]$s$から全頂点へのパレート最適解となる経路の集合
\end{itemize}

\begin{description}
  \item[パレート最適解の集合の数に対する問題の難しさ]
\end{description}

一般的に多目的最適化問題は出力となるパレート最適解の数に比例して解くことが難しくなる．
これは解の探索をするとともに，パレート最適解であるかどうかの判定のために既知の解と比較をするためである．
単目的最短経路問題の場合，１つの頂点に1つの解しか存在しないため既知の解との比較は１回である．
しかし，多目的最適問題の場合，１つの頂点に対して始点と終点を結ぶpathの本数分の解が存在する．
任意の頂点$v \in V$を選択する．頂点集合$V$から始点$s$と$v$を除いた頂点集合を$V'=V \setminus \{s\}$とする．
pathは始点から終点への通過する頂点の順番で表されるため，通過する頂点の集合の並び替えの数だけ存在する．
$s$から$v$へのpathの数は$V'$から$i$個の頂点を選択し並び変えた数だけ存在する．
頂点数を$|N|=n$とすると$V'$の要素数は$|V'|=n-2$なので，
$\displaystyle \sum_{i=0}^{n-2} {}_{(n-2)}C_i i!$で表される．
よって，既知の解との比較は最大で$\displaystyle \sum_{i=0}^{n-2} {}_{(n-2)}C_i i!$回である．
既知の解との比較は，単目的最短経路問題では1回であり，
多目的最適問題では最大で$\displaystyle \sum_{i=0}^{n-2} {}_{(n-2)}C_i i!$回であるため
パレート最適解の数に比例して解くことが難しくなる．
パレート最適解の数に比例して解くことが難しくなることを照明したため，
それぞれのインスタンスに対してパレート最適解の数がどのように変化するか分析する．

\begin{description}
  \item[頂点数に対する問題の難しさ]
\end{description}

パレート最適解の数が問題の難しさに直結することを示した．頂点数に対する問題の難しさを分析するために，
入力の頂点数$|V|=n$によりパレート最適解の数がどのように変化するか分析する．
頂点数とパレート最適解の集合の数の関係を分析するためにその他の入力は
辺の重みベクトルの値がランダムであり，重みの範囲が十分に大きい完全グラフとする．
多目的最短経路問題の場合，解は始点から各頂点へのpathの本数分存在する．
頂点集合$V$から始点$s$を除いた頂点集合を$V'=V \setminus \{s\}$とする．
pathは始点から終点への通過する頂点の順番で表されるため，通過する頂点の集合の並び替えの数だけ存在する．
完全グラフにおいて始点から各頂点へのpathの合計は$V'$から$i$個の頂点を選択し並び変えた数だけ存在する．
$V'$の要素数は$|V'|=n-1$なので，$\displaystyle \sum_{i=0}^{n-1} {}_{(n-1)}C_i i!$で表される．
以上より，頂点数が大きくなるとパレート最適解の数は指数的に増えるため，頂点数が大きくなると
問題は難しくなる．

\begin{description}
  \item[重みの範囲に対する問題の難しさ]
\end{description}

パレート最適解の数が問題の難しさに直結することを示した．重みの範囲に対する問題の難しさを分析するために，
全ての重みが非負数である完全グラフにおいて重みの範囲によりパレート最適解の数がどのように変化するか分析する．
重みの範囲によりパレート最適解の集合の数の関係を分析するためにその他の入力は
辺の重みベクトルの値がランダムであり，頂点数が十分に大きい完全グラフとする．
始点$s$から終点$t$への最短経路を求める．頂点$v$を経由した$s$から$t$への経路を$(s,v,t)$と表す．
非負数であるグラフにおいて，経由する頂点数が多くなるほど各目的関数の値は大きくなるため，
経路$(s,t)$が経路$(s,v,t)$を支配する確率は高くなる．
また，経路$(s,t)$が$i$個の頂点を経由する経路$(s,v_1,\ldots,v_i,t)$を支配する確率も高くなる．
ここで，重みの範囲が広くなると経路$(s,v,t)$が解となる確率は高くなるため解の数は多くなると予想される．
経由する頂点１つの場合，重みの範囲に対して解になる確率が高くなることを示したが，経由する頂点数が増加した場合でも
同じく重みの範囲に対して解になる確率が高くなると予想されるため全体の解の数はさらに多くなると予想される．
経由する頂点数が増えるほど解になる確率が低くなっていくが，重みの範囲が広くなると解の確率は上がるため，
一定の範囲で２つの確率が相殺しあうため，重みの範囲が一定の値を越えると解は増えなくなる．
以上より，重みの範囲が広くなると最適解の数は増えるため，重みの範囲が広くなると問題は難しくなる．


証明：
最適化目的の数が２$(f_1,f_2)$，重みの範囲が１であるグラフを考える．任意の２頂点間の目的関数の組み合わせは
$f_1$が$0,1$の２通り，$f_2$が$0,1$の２通りなので$2 \times 2$の４通りである．
経路$(s,t)$が経路$(s,v,t)$の組み合わせは経路３本の組み合わせなので$4^3 = 64$通り．
ここで，経路$(s,t)$が経路$(s,v,t)$を支配するまたは同値である組み合わせを考える．
上記の組み合わせが成立するためには以下が成り立たなければならない．経路$(s,t)$の各目的関数$f_{st1},f_{st2}$，
経路$(s,v)$の各目的関数$f_{sv1},f_{sv2}$，経路$(v,t)$の各目的関数$f_{vt1},f_{vt2}$において
$f_{st1}>f_{sv1}+f_{vt1}$または$f_{st2}>f_{sv2}+f_{vt2}$．これは$f_{st1}=1$かつ$f_{sv1}+f_{vt1}=0$,
$f_{st2}=1$かつ$f_{sv2}+f_{vt2}=0$なので$2^3+2^3-1=15$通り．
よって経路$(s,v,t)$が解となる確率は$15/64=0.234$である．
最適化目的の数が２$(f_1,f_2)$，重みの範囲が２であるグラフを考える．任意の２頂点間の目的関数の組み合わせは
$f_1$が$0,1,2$の２通り，$f_2$が$0,1,2$の３通りなので$3 \times 3$の９通りである．
経路$(s,t)$が経路$(s,v,t)$の組み合わせは経路３本の組み合わせなので$9^3 = 729$通り．
ここで，経路$(s,t)$が経路$(s,v,t)$を支配するまたは同値である組み合わせを考える．
上記の組み合わせが成立するためには以下が成り立たなければならない．経路$(s,t)$の各目的関数$f_{st1},f_{st2}$，
経路$(s,v)$の各目的関数$f_{sv1},f_{sv2}$，経路$(v,t)$の各目的関数$f_{vt1},f_{vt2}$において
$f_{st1}>f_{sv1}+f_{vt1}$または$f_{st2}>f_{sv2}+f_{vt2}$．
これは$(3^3+3^3-1)+(3 \times 3^3 + 3 \times 3^3 - 3)=53+159=212$通り．
よって経路$(s,v,t)$が解となる確率は$212/729=0.291$である．
以上より，重みの範囲が広くなると経路$(s,v,t)$が解となる確率は高くなる．

\begin{description}
  \item[最適化目的の数に対する問題の難しさ]
\end{description}

パレート最適解の数が問題の難しさに直結することを示した．最適化目的の数に対する問題の難しさを分析するために，
全ての重みが非負数である完全グラフにおいて最適化目的の数によりパレート最適解の数がどのように変化するか分析する．
最適化目的の数によりパレート最適解の集合の数の関係を分析するためにその他の入力は
辺の重みベクトルの値がランダムかつ重みの範囲が十分に大きい値であり，頂点数が十分に大きい完全グラフとする．
始点$s$から終点$t$への最短経路を求める．頂点$v$を経由した$s$から$t$への経路を$(s,v,t)$と表す．
非負数であるグラフにおいて，経由する頂点数が多くなるほど各目的関数の値は大きくなるため，
経路$(s,t)$が経路$(s,v,t)$を支配する確率は高くなる．
また，経路$(s,t)$が$i$個の頂点を経由する経路$(s,v_1,\ldots,v_i,t)$を支配する確率も高くなる．
最適化目的の数が２の場合と３の場合を比較する．$(s,t)$の各目的関数を$f_{st1},f_{st2},f_{st3}$，
$(s,v,t)$の各目的関数を$f_{svt1},f_{svt2},f_{svt3}$とする．
経路$(s,v,t)$が解となるためには１つでも目的関数が$(s,t)$より低ければ良い．
つまり，$\exists i ,f_{svti}<f_{sti}$が成り立てば良い．
最適化目的の数が２の場合$i$の選択肢は２つだが，最適化目的の数が３の場合$i$の選択肢は３つとなり
$\exists i ,f_{svti}<f_{sti}$が成り立つ可能性が高くなる．
よって，最適化目的の数が増えると頂点を１つ経由した経路が解となる確率が高くなる．
経由する頂点数が増えた場合でも同じことが言えるので全体の解の数はさらに増えると予想される．
以上より，最適化目的の数が増えると最適解の数は増えるため，最適化目的の数が増えると問題は難しくなる．

\begin{description}
  \item[辺の本数に対する問題の難しさ]
\end{description}

パレート最適解の数が問題の難しさに直結することを示した．辺の本数に対する問題の難しさを分析するために，
全ての重みが非負数であるグラフにおいて辺の本数によりパレート最適解の数がどのように変化するか分析する．
辺の本数によりパレート最適解の集合の数の関係を分析するためにその他の入力は，最適化目的の数が$k$，
辺の重みベクトルの値がランダム，重みの範囲が十分に大きい，頂点数が十分に大きいグラフとする．
始点$s$から終点$t$への最短経路を求める．頂点$v$を経由した$s$から$t$への経路を$(s,v,t)$と表す．
完全グラフの場合，頂点を１つ経由する経路は始点と終点を除いた頂点集合から１頂点を選択した経路なので
$n-2$通り存在する．グラフ上の$s$と$t$を除いた頂点集合の任意の頂点$v'$について，$s$と$v'$
を結ぶ辺が存在しない又は$v'$と$t$を結ぶ辺が存在しないとき，頂点$v'$を通る経路$(s,v,t)$は存在しない．
また，頂点$u$と頂点$u'$を結ぶ辺が存在しないとき，$(s,\ldots, u, u', \ldots , t$となるような経路は存在しない．
このように辺の本数が少なくなると，グラフ上の経路は少なくなるため解の候補となる経路の数が減少する．
よって，全体の解の数は少なくなる．単一始点最短経路問題において，始点$s$を中心としたスターグラフ内の
解となり得る経路は$n-1$本存在する．単一始点最短経路問題において，完全グラフ内の解となり得る経路は
$\displaystyle \sum_{i=0}^{n-1} {}_{(n-1)}C_i i!$本存在する．
以上より，辺の本数が増えると最適解の数は増えるため，辺の本数が増えると問題は難しくなる．

\begin{description}
  \item[各目的関数間の相関に対する問題の難しさ]
\end{description}

パレート最適解の数が問題の難しさに直結することを示した．各目的関数間の相関に対する問題の難しさを分析するために，
全ての重みが非負数である完全グラフにおいて各目的関数間の相関によりパレート最適解の数がどのように変化するか分析する．
各目的関数間の相関によりパレート最適解の集合の数の関係を分析するためにその他の入力は，最適化目的の数が３，
辺の重みベクトルの値がランダム，重みの範囲が十分に大きい，頂点数が十分に大きい完全グラフとする．
相関は−１〜１で表され，−１に近いほど負の相関があり，０に近いほど相関がなく，１に近いほど正の相関があるという．
以下では頂点に入ってくる辺の重みベクトルに対する相関と頂点から出ていく辺の重みベクトルに対する相関に対する分析を行う．

頂点に入ってくる辺の重みベクトルに対する相関に対する分析．
最適化目的の数３のため，各目的関数を$(f_1,f_2,f_3)$とし，任意の辺$e　\in E$における重みベクトルを
$\vec{e}=(e(f_1),e(f_2),e(f_3))$とする．終点が頂点$u$である辺（頂点$u$に入ってくる辺）の集合を$E_u$とする．
頂点に入ってくる辺の重みベクトルに対する相関とは３つある．$\forall E_v , v \in V$に対する相関であり，それぞれ
$\{f_1,f_2\}$間の相関$c_{12}$，$\{f_2,f_3\}$間の相関$c_{23}$，$\{f_1,f_3\}$間の相関$c_{13}$である．
$c_{12}=1$のとき，任意の辺$x,v\in E$に対して，$x(f_1)=x(f_2)\times l$のとき$y(f_1)=y(f_2)\times l$が成り立つ．
つまり，$c_{12}=1$のとき，任意の辺$x,v\in E$に対して，$x(f_1)<x(f_2) \land y(f_1)<y(f_2)$または
$x(f_1)=x(f_2) \land y(f_1)=y(f_2)$または$x(f_1)>x(f_2) \land y(f_1)>y(f_2)$が成り立つ．
$c_{12}=1,c_{23}=1$のとき$c_{13}=1$である．このとき，任意の辺$e \ inE$を$\vec{e}=(e(f_1),e(f_2),e(f_3))$とすると
$\forall e'\in E,\vec{e'} = l\times(e(f_1),e(f_2),e(f_3))$が成り立つため各頂点に対する解の数はそれぞれ１となり，
全体の解の数は$|N|$となる．また，各目的関数間の相関が強ければ強いほど頂点$u\in V$における$s$からの経路$u'_{s}$と
$u''_{s}$に対して，支配関係（$u'_{s}$が$u''_{s}$を支配するまたは$u''_{s}$が$u'_{s}$を支配する）が成り立つ可能性が
高いため全体の解の数は少なくなる．
以上より，頂点に入ってくる辺の重みベクトルに対する相関が弱いと最適解の数は増えるため，
頂点に入ってくる辺の重みベクトルに対する相関が弱いと問題は難しくなる．


頂点から出ていく辺の重みベクトルに対する相関に対する分析．
最適化目的の数３のため，各目的関数を$(f_1,f_2,f_3)$とし，任意の辺$e　\in E$における重みベクトルを
$\vec{e}=(e(f_1),e(f_2),e(f_3))$とする．始点が頂点$u$である辺（頂点$u$から出ていく辺）の集合を$E_u$とする．
頂点から出ていく辺の重みベクトルに対する相関とは３つある．$\forall E_v , v \in V$に対する相関であり，それぞれ
$\{f_1,f_2\}$間の相関$c_{12}$，$\{f_2,f_3\}$間の相関$c_{23}$，$\{f_1,f_3\}$間の相関$c_{13}$である．
$c_{12}=1$のとき，任意の辺$x,v\in E$に対して，$x(f_1)=x(f_2)\times l$のとき$y(f_1)=y(f_2)\times l$が成り立つ．
つまり，$c_{12}=1$のとき，任意の辺$x,v\in E$に対して，$x(f_1)<x(f_2) \land y(f_1)<y(f_2)$または
$x(f_1)=x(f_2) \land y(f_1)=y(f_2)$または$x(f_1)>x(f_2) \land y(f_1)>y(f_2)$が成り立つ．
$c_{12}=1,c_{23}=1$のとき$c_{13}=1$である．このとき，任意の辺$e \ inE$を$\vec{e}=(e(f_1),e(f_2),e(f_3))$とすると
$\forall e'\in E,\vec{e'} = l\times(e(f_1),e(f_2),e(f_3))$が成り立つため各頂点に対する解の数はそれぞれ１となり，
全体の解の数は$|N|$となる．また，各目的関数間の相関が強ければ強いほど頂点$u\in V$における$s$からの経路$u'_{s}$と
$u''_{s}$に対して，支配関係（$u'_{s}$が$u''_{s}$を支配するまたは$u''_{s}$が$u'_{s}$を支配する）が成り立つ可能性が
高いため全体の解の数は少なくなる．
以上より，頂点から出ていく辺の重みベクトルに対する相関が弱いと最適解の数は増えるため，
頂点から出ていく辺の重みベクトルに対する相関が弱いと問題は難しくなる．


\begin{description}
  \item[多目的最短経路問題に対する単目的最短経路問題アルゴリズムの実装]
\end{description}

入力が，頂点集合$V$（$|V|=n$），最適化目的の数が$k$，
辺の重みベクトルの値がランダム(相関がない)，重みの範囲が十分に大きい，完全グラフとする．
本研究では重みがランダム（異なる）単一始点最短経路を扱うため，単一目的最短経路問題での解法は
ダイクストラ法とベルマンフォード法である．（重みが決まった値でないため幅優先探索は扱えない．
全点対最短経路でないためワーシャルフロイド法は効率的でない．）
多目的最短経路問題に対するダイクストラ法とベルマンフォード法の適用を実装し，それぞれの問題点と活用方法を分析する．

ダイクストラ法の適用．ダイクストラ法はすでに探索済みのノードの中で重みが最小のノードを
求め，更新対象として探索していくアルゴリズムである．全ての重みが非負数の場合，探索したノードの中で重みが最小のものは
その後の探索で更新されることはないので重みが決定する．多目的最短経路問題にダイクストラ法を適用すると
すでに探索済みのpathの中で重みが最小のpathを求め，更新対象として探索していく．
全ての重みが非負数の場合，探索したpathの中で重みが最小のものはその後の探索で支配されることはないので解として決定する．
ダイクストラ法の問題点は重みが最小であるpathの探索であり，理由は２つある．１つ目の理由は多目的最適化問題においてpathは
複数の目的関数を所持しているため最小である基準が明確でないことである．単目的最短経路問題では目的関数が１つ
のためその目的関数が最小のpath（頂点）を選択すれば良い．目的関数が複数である多目的最短経路問題では，
各目的関数に対して評価値をもうけ優先順位をつける方法（例：目的関数が$f_1,f_2,f_3$のとき
$f_2 \rightarrow f_1 \rightarrow f_3 $という優先順位をつける）や１つの目的関数として計算する方法
（例：目的関数が$f_1,f_2,f_3$のとき$f_x = f_1 + f_2 \times 2 + f_3 \times 4$という目的関数を計算する）
が考えられる．もう１つの問題は重みが最小であるpath（更新対象）の探索するために多くの比較が必要となることである．
単目的最短経路問題の場合選択肢となるpath（頂点）は頂点数分なので最大で$|N|$つあるが，多目的最短経路の場合
選択肢となるpathは１頂点に対して複数存在するため最大で$\displaystyle \sum_{i=0}^{n-1} {}_{(n-1)}C_i i!$
つとなる．探索のたびにこれらのpathの中から１つのpathを選択するには毎回それぞれの値を比較して
対象となるpathを求めなければならないため膨大な計算時間がかかる．これらの問題に対して
pathが発見されるたびに更新順のリストに保存していく方法があるが，リストへの保存に対しても
多くの計算時間がかかるため問題は難しいままである．

ベルマンフォード法の適用．ベルマンフォード法は頂点数を $|V|$ とした時，全辺を緩めることを単に $|V|-1$ 回繰り返すアルゴリズムである．
多目的最短経路問題にベルマンフォード法を適用すると，単目的最短経路問題と同じように頂点数を $|V|$ とした時，
全辺を緩めることを単に $|V|-1$ 回繰り返す．ダイクストラ法と違い，更新対象を探索する操作がないため
ダイクストラ法のボトルネックとなっていた目的関数が最小のpath（頂点）を選択するための比較や計算をしなくて済む．
しかし，全辺を緩める操作のときにすでに更新したpathまで更新対象としてしまうため無駄が生じてしまう．
単目的最短経路問題の場合，各頂点に最大で１つの解（path）が存在するため１回の全辺を緩める操作で更新対象となるのは
最大で頂点数である$|V|$である．一方，多目的最短経路問題では各頂点に最大で始点からのpathの本数分
（完全グラフの場合，存在する始点からのpathの本数は$\displaystyle \sum_{i=0}^{n-2} {}_{(n-2)}C_i i!$本）
存在する．また，１回の全辺を緩める操作で更新対象となるのは最大で$\displaystyle \sum_{i=0}^{n-1} {}_{(n-1)}C_i i!$つとなる．
そのため，全辺を緩めることを単に $|V|-1$ 回繰り返してしまうと膨大な計算時間がかかってしまう．

\section{非負数の問題に対する解法の提案}
非負数である多目的最短経路問題における解法を提案する．

\subsection{提案解法１}
多目的最短経路問題に対する単目的最短経路問題アルゴリズムの実装で述べたようにダイクストラ法とベルマンフォード法
にはそれぞれボトルネックがあるため改良が必要である．ダイクストラ法のボトルネックである更新対象の探索
はヒープを用いた方法やpathが発見されるたびに更新順のリストに保存していく方法があるが目的関数が増えていくと
これらの操作時間にも計算時間がかかってしまうため現実的でない．一方，ベルマンフォード法は改善によって
ボトルネックを解決できる．そのため，最適な解法を得るためにベルマンフォード法の改善をしていく．

まず，ベルマンフォード法のボトルネックである全辺を緩めることを単に$|V|-1$ 回繰り返してしまうと膨大な計算時間がかかってしまう
という問題と，１回の全辺を緩める操作で更新対象となるのは最大で$\displaystyle \sum_{i=0}^{n-1} {}_{(n-1)}C_i i!$つとなる問題を
解決した解法を以下に記載する．


\begin{quote}
  \textbf{記号}
  \begin{description}
    \item[$k$：] 最適化目的の数
    \item[$L$：] 解となるラベル
    \item[$X$：] 更新対象とする頂点集合
    \item[$v \in V$，$j = 1 , \ldots , k$に対して]
    \item[$l_{jv}$：] 始点からノード$v$に到達したときに生じる
    第$j$番目の目的関数における総コスト
    \item[$e \in E$，$j = 1 , \ldots , k$に対して]
    \item[$e_{jw}$：] 辺$e$の第$j$番目の目的関数におけるコスト
  \end{description}
\end{quote}

\begin{quote}
  \textbf{アルゴリズム}
  \begin{description}
    \item[入力：] グラフ$G=(V,E)$，始点$s \in V$，最適化目的の数$k$，
    各辺の重みを返す関数$w : E \to \mathbb{R}^k$
    \item[出力：] $s$から全ての頂点への最短経路となるパレート解の集合
    \item[Step 1.] $\forall v \in V , L_v \leftarrow \emptyset$，
    $L_s \leftarrow (s,0,\ldots,0)$，$X \leftarrow s$
    \item[Step 2.] $X = \{\emptyset\}$となるまで以下の操作を行う．
    \begin{description}
      \item[Step 2-1.] $v \in X$となる頂点$v$を選択する．
      \item[Step 2-2.] $X \leftarrow X \setminus \{ v \}$
      \item[Step 2-3.] $e = {e \in E \mid v,u \in e}$となる
      $e$に対して以下の操作を行う．
      \begin{description}
        \item[Step 2-3-1.] 頂点$v$に対する全てのpath
        $(v',l_{1v'},\ldots,l_{kv'}) \in L,v=v'$に対して以下の操作を行う．
        \begin{description}
          \item[Step 2-3-1-1.] 辺$e$の重みベクトルを
          $\vec{e} = (e_{1w},\ldots,e_{kw})$とし，
          $(u',l_{1u'},\ldots,l_{ku'}) \leftarrow
          (u',l_{1v}+e_{1w},\ldots,l_{kv}+e_{kw})$とする．
          \item[Step 2-3-1-2.] 以下の条件を満たすとき，
          $L \leftarrow L \cup \{(u',l_{1u'},\ldots,l_{ku'})\}$，
          $X \leftarrow X \cup \{ u\}$とする．
          \begin{itemize}
            \item 任意の$(u^*,l_{1u^*},\ldots,l_{ku^*})\in L,u=u^*$に
            $(u',l_{1u'},\ldots,l_{ku'})$が支配されない．
            \item 任意の$(u^*,l_{1u^*},\ldots,l_{ku^*}) \in L,u=u^*$と
            $(u',l_{1u'},\ldots,l_{ku'})$における全ての目的関数値が同値でない．
          \end{itemize}
          \item[Step 2-3-1-3.] 任意の$(u'',l_{1u''},\ldots,l_{ku''})\in Lu=u''$
          に対して$(u',l_{1u'},\ldots,l_{ku'})$が
          $(u'',l_{1u''},\ldots,l_{ku''})$を支配しているとき，
          $L \leftarrow L \setminus \{(u'',l_{1u''},\ldots,l_{ku''})\}$とする．
        \end{description}
      \end{description}
    \end{description}
    \item[Step 3.] 全てのパレート解を出力
  \end{description}
\end{quote}

\begin{quote}
  \textbf{支配}

    解 $x,y$ が以下の条件を満たすとき，$x$ は $y$ を支配する．
    \begin{itemize}
      \item $\forall i \in \{1,\ldots,k\},f_i(x) \le f_i(y)$
      \item $\exists i \in \{1,\ldots,k\},f_i(x) < f_i(y)$
      \item $k$：最適化目的の数，$f$：目的関数
    \end{itemize}
\end{quote}


上記の解法は更新によって新たな解を得た頂点を更新対象となる頂点集合に加えることによって，更新しなくて良い頂点を
更新せずに済む．これにより，１回の全辺を緩める操作で更新対象となるのは最大で
$\displaystyle \sum_{i=0}^{n-1} {}_{(n-1)}C_i i!$つとなる問題を解決した．



\begin{quote}
  \textbf{記号}
  \begin{description}
    \item[$k$：] 最適化目的の数
    \item[$v \in V$に対して]
    \item[$L_v$：] 頂点$v$に対するラベル
    \item[$M(L_v)$：] 頂点$v$に対するラベルにおいて，更新対象とその他の境界となる解
    （$M(L_v)$が$L_v$のi番目の解のとき，i+1番目以降の解は更新対象とする）
    \item[$v \in V$，$j = 1 , \ldots , k$に対して]
    \item[$l_{jv}$：] 始点からノード$v$に到達したときに生じる
    第$j$番目の目的関数における総コスト
    \item[$e \in E$，$j = 1 , \ldots , k$に対して]
    \item[$e_{jw}$：] 辺$e$の第$j$番目の目的関数におけるコスト
  \end{description}
\end{quote}

\begin{quote}
  \textbf{アルゴリズム}
  \begin{description}
    \item[入力：] グラフ$G=(V,E)$，始点$s \in V$，最適化目的の数$k$，
    各辺の重みを返す関数$w : E \to \mathbb{R}^k$
    \item[出力：] $s$から全ての頂点への最短経路となるパレート解の集合
    \item[Step 1.] $\forall v \in V , L_v \leftarrow \emptyset$，
    $L_s \leftarrow (s,0,\ldots,0)$
    \item[Step 2.] 更新ができなくなるまで以下の操作を行う．
    \begin{description}
      \item[Step 2-1.] $\forall v \in V$となる頂点$v$に対して以下の操作を行う．
      \begin{description}
        \item[Step 2-1-1.] $\forall u \in V$となる頂点$u$に対して以下の操作を行う．
        \begin{description}
          \item[Step 2-1-1-1.] $L_v$から$L_u$に対しての更新を行う．
        \end{description}
        \item[Step 2-1-2.] $M(L_v)$を$L_v$の最後の解とする．
      \end{description}
    \end{description}
    \item[Step 3.] 全てのパレート解を出力
  \end{description}
\end{quote}

\begin{quote}
  \textbf{$L_v$から$L_u$に対しての更新}
  \begin{description}
    \item[Step 1.] $L_v$，$L_u$，頂点$v$から頂点$u$への辺$e$を受け取る．
    \item[Step 2.] $M(L_v)$より後にある全ての解$(v',l_{1v'},\ldots,l_{kv'}) \in L_v$
    について以下の操作を行う．
    \begin{description}
      \item[Step 2-1.] 辺$e$の重みベクトルを
      $\vec{e} = (e_{1w},\ldots,e_{kw})$とし，
      $(u',l_{1u'},\ldots,l_{ku'}) \leftarrow
      (u',l_{1v}+e_{1w},\ldots,l_{kv}+e_{kw})$とする．
      \item[Step 2-2.] 以下の条件を満たすとき，
      $L_u \leftarrow L_u \cup \{(u',l_{1u'},\ldots,l_{ku'})\}$とする．
      \begin{itemize}
        \item 任意の$(u^*,l_{1u^*},\ldots,l_{ku^*})\in L_u$に
        $(u',l_{1u'},\ldots,l_{ku'})$が支配されない．
        \item 任意の$(u^*,l_{1u^*},\ldots,l_{ku^*}) \in L_u$と
        $(u',l_{1u'},\ldots,l_{ku'})$における全ての目的関数値が同値でない．
      \end{itemize}
      \item[Step 2-3.] 任意の$(u'',l_{1u''},\ldots,l_{ku''})\in L_u$
      に対して$(u',l_{1u'},\ldots,l_{ku'})$が
      $(u'',l_{1u''},\ldots,l_{ku''})$を支配しているとき
      $L_u \leftarrow L_u \setminus \{(u'',l_{1u''},\ldots,l_{ku''})\}$とする．
    \end{description}
  \end{description}
\end{quote}

\begin{quote}
  \textbf{支配}

    解 $x,y$ が以下の条件を満たすとき，$x$ は $y$ を支配する．
    \begin{itemize}
      \item $\forall i \in \{1,\ldots,k\},f_i(x) \le f_i(y)$
      \item $\exists i \in \{1,\ldots,k\},f_i(x) < f_i(y)$
      \item $k$：最適化目的の数，$f$：目的関数
    \end{itemize}
\end{quote}

\subsection{提案解法２}
\begin{quote}
  \textbf{記号}
  \begin{description}
    \item[$k$：] 最適化目的の数
    \item[$v \in V$に対して]
    \item[$L_{vx}$：] 頂点$v$に対する，更新対象としないラベル
    \item[$L_{vy}$：] 頂点$v$に対する，更新対象とするラベル
    \item[$L_{vz}$：] 頂点$v$に対する，次回探索で更新対象とするラベル
    \item[$v \in V$，$j = 1 , \ldots , k$に対して]
    \item[$l_{jv}$：] 始点からノード$v$に到達したときに生じる
    第$j$番目の目的関数における総コスト
    \item[$e \in E$，$j = 1 , \ldots , k$に対して]
    \item[$e_{jw}$：] 辺$e$の第$j$番目の目的関数におけるコスト
  \end{description}
\end{quote}

\begin{quote}
  \textbf{アルゴリズム}
  \begin{description}
    \item[入力：] グラフ$G=(V,E)$，始点$s \in V$，最適化目的の数$k$，
    各辺の重みを返す関数$w : E \to \mathbb{R}^k$
    \item[出力：] $s$から全ての頂点への最短経路となるパレート解の集合
    \item[Step 1.] $\forall v \in V , L_v \leftarrow \emptyset$，
    $L_{sy} \leftarrow (s,0,\ldots,0)$
    \item[Step 2.] 更新ができなくなるまで以下の操作を行う．
    \begin{description}
      \item[Step 2-1.] $\forall v \in V$となる頂点$v$に対して以下の操作を行う．
      \begin{description}
        \item[Step 2-1-1.] $\forall u \in V$となる頂点$u$に対して以下の操作を行う．
        \begin{description}
          \item[Step 2-1-1-1.] $L_{vy}$から$L_u$に対しての更新を行う．
        \end{description}
      \end{description}
      \item[Step 2-2.] $\forall v \in V$に対して
      $L_{vx},L_{vy},L_{vz}$の更新を行う．
    \end{description}
    \item[Step 3.] 全てのパレート解を出力
  \end{description}
\end{quote}

\begin{quote}
  \textbf{$L_{vy}$から$L_u$に対しての更新}
  \begin{description}
    \item[Step 1.] $L_{vy}$，$L_u$，頂点$v$から頂点$u$への辺$e$を受け取る．
    \item[Step 2.] $\forall (v',l_{1v'},\ldots,l_{kv'}) ,
    (v',l_{1v'},\ldots,l_{kv'}) \in L_{vy}$について以下の操作を行う．
    \begin{description}
      \item[Step 2-1.] 辺$e$の重みベクトルを
      $\vec{e} = (e_{1w},\ldots,e_{kw})$とし，
      $(u',l_{1u'},\ldots,l_{ku'}) \leftarrow
      (u',l_{1v}+e_{1w},\ldots,l_{kv}+e_{kw})$とする．
      \item[Step 2-2.] 以下の条件を満たすとき，
      $L_{uz} \leftarrow L_{uz} \cup \{(u',l_{1u'},\ldots,l_{ku'})\}$とする．
      \begin{itemize}
        \item 任意の$(u^*,l_{1u^*},\ldots,l_{ku^*})\in \{L_{ux} \cup L_{uy} \cup L_{uz}\}$に
        $(u',l_{1u'},\ldots,l_{ku'})$が支配されない．
        \item 任意の$(u^*,l_{1u^*},\ldots,l_{ku^*}) \in \{L_{ux} \cup L_{uy} \cup L_{uz}\}$と
        $(u',l_{1u'},\ldots,l_{ku'})$における全ての目的関数値が同値でない．
      \end{itemize}
      \item[Step 2-3.] 任意の$(u'',l_{1u''},\ldots,l_{ku''})\in L_{ux}$
      に対して$(u',l_{1u'},\ldots,l_{ku'})$が
      $(u'',l_{1u''},\ldots,l_{ku''})$を支配しているとき
      $L_{ux} \leftarrow L_{ux} \setminus \{(u'',l_{1u''},\ldots,l_{ku''})\}$とする．
      \item[Step 2-4.] 任意の$(u'',l_{1u''},\ldots,l_{ku''})\in L_{uy}$
      に対して$(u',l_{1u'},\ldots,l_{ku'})$が
      $(u'',l_{1u''},\ldots,l_{ku''})$を支配しているとき
      $L_{uy} \leftarrow L_{uy} \setminus \{(u'',l_{1u''},\ldots,l_{ku''})\}$とする．
      \item[Step 2-5.] 任意の$(u'',l_{1u''},\ldots,l_{ku''})\in L_{uz}$
      に対して$(u',l_{1u'},\ldots,l_{ku'})$が
      $(u'',l_{1u''},\ldots,l_{ku''})$を支配しているとき
      $L_{uz} \leftarrow L_{uz} \setminus \{(u'',l_{1u''},\ldots,l_{ku''})\}$とする．
    \end{description}
  \end{description}
\end{quote}

\begin{quote}
  \textbf{$L_{vx},L_{vy},L_{vz}$の更新}
  \begin{description}
    \item[Step 1.] $L_{vx},L_{vy},L_{vz}$を受け取る．
    \item[Step 2.] $L_{vx} = L_{vx} \cup L_{vy}$とし，
    $L_{vy} = \{ \emptyset \}$とする．
    \item[Step 3.] $L_{vy} \leftarrow L_{vz}$とし，
    $L_{vz} = \{ \emptyset \}$とする．
  \end{description}
\end{quote}

\begin{quote}
  \textbf{支配}

    解 $x,y$ が以下の条件を満たすとき，$x$ は $y$ を支配する．
    \begin{itemize}
      \item $\forall i \in \{1,\ldots,k\},f_i(x) \le f_i(y)$
      \item $\exists i \in \{1,\ldots,k\},f_i(x) < f_i(y)$
      \item $k$：最適化目的の数，$f$：目的関数
    \end{itemize}
\end{quote}

\section{負の値の考慮した問題に対する解法の提案}
提案解法2を基に負の値の考慮を行う．

\section{実装における工夫}

\section{提案解法の評価と分析}

\chapter{結論}

\section{研究成果}

\section{今後の課題}

\bibliographystyle{splncs03}
\addcontentsline{toc}{chapter}{\bibname}
\bibliography{thesis_nakano}
\appendix

\chapter*{謝辞}
本研究を進めるにあたり，指導教員の宋 少秋教授には研究に対する助言や熱心な指導
をしていただきましたことを心から感謝いたします．またゼミや日常で多くの
知識や示唆をいただいた研究室の先輩，
同期の方々に感謝いたします．

\begin{flushright}
  2019年1月31日 \氏名
\end{flushright}
\endmatter % 削除しないように！
\end{document}
